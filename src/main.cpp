#include "utils.cpp"
#include <cassert>
#include <cstdint>
#include <cstring>
#include <iostream>
#include <vector>

#include <arpa/inet.h>
#include <poll.h>
#include <sys/socket.h>
#include <unistd.h>

// Socket Configs
#define PORT_NO 1234 // Port number
#define IP_ADDR 0    // wildcard IP 0.0.0.0

#define MAX_MSG_LEN 4069

struct Conn {
    int fd = -1;

    // application's intentions for the event loop
    bool want_read = false;
    bool want_write = false;
    bool want_close = false;

    // buffered i/o
    std::vector<uint8_t> incoming; // data to be parsed by the application
    std::vector<uint8_t> outgoing; // responses generated by the application
};

void buf_append(std::vector<uint8_t> &buf, const uint8_t *data, size_t len) {
    buf.insert(buf.end(), data, data + len);
}

void buf_consume(std::vector<uint8_t> &buf, size_t n) {
    buf.erase(buf.begin(), buf.begin() + n);
}

bool try_handling_request(Conn *conn) {

    /*
        protocol spec

        [4 bytes]   (size of msg)
        [n bytes]   (msg of n bytes)
        [4 bytes]
        [n bytes]
        ...

    */

    // try to parse accumulated buffer
    // Protocol: message header
    if (conn->incoming.size() < 4) {
        return false; // want read
    }

    uint32_t len = 0;
    memcpy(&len, conn->incoming.data(), 4);

    if (len > MAX_MSG_LEN) { // protocol error
        conn->want_close = true;
        return false; // want close
    }

    // Protocol: message body
    if (conn->incoming.size() < 4 + len) {
        return false; // want read
    }

    const uint8_t *request = &conn->incoming[4];

    // process the messsage
    // extract clients info
    struct sockaddr_in addr = {};
    socklen_t addr_len = sizeof(addr);
    getpeername(conn->fd, (struct sockaddr *)&addr, &addr_len);

    // convert addr to readable form
    char ip_str[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &addr.sin_addr, ip_str, sizeof(ip_str));

    std::cout << "Message recieved from client " << ip_str << ":"
              << addr.sin_port << std::endl;

    std::cout << "Message length: " << len << std::endl;

    std::string msg(conn->incoming.begin(), conn->incoming.end());
    std::cout << "Message content: " << msg << std::endl;

    // generate response + resp. len
    // append to output (currently echo)
    buf_append(conn->outgoing, (const uint8_t *)&len, 4);
    buf_append(conn->outgoing, request, len);

    // remove from incoming buffer
    buf_consume(conn->incoming, 4 + len);
    return true; // success
}

Conn *handle_accept(int fd) {
    // accept
    struct sockaddr_in client_addr = {};
    socklen_t addrlen = sizeof(client_addr);

    int conn_fd = accept(fd, (struct sockaddr *)&client_addr, &addrlen);

    if (conn_fd < 0) {
        // error
        std::cerr << "Unable to connect to this client..." << std::endl;
        return NULL;
    }

    // set connection fd to nonblocking mode
    fd_set_nonblock(conn_fd);

    // create a Conn struct
    Conn *conn = new Conn();
    conn->fd = conn_fd;
    conn->want_read = true; // read 1st request
    return conn;
}

void handle_read(Conn *conn) {
    // Do a non blocking read
    uint8_t buf[64 * 1024];
    ssize_t rv = read(conn->fd, buf, sizeof(buf));

    if (rv <= 0) {
        // Handle i/o error or EOF
        conn->want_close = true;
        return;
    }

    // add data to incoming buffer
    buf_append(conn->incoming, buf, (size_t)rv);

    // try to parse incoming messages
    // up until no message if left in buffer
    // (pipilined/batched requests)
    // process parsed message
    // remove from buffer
    while(true){
        if(!try_handling_request(conn)){
            break;
        }
    }

    // switch state to write if data is ready to be written
    if (conn->outgoing.size() > 0) {
        // want write if some data in buf to write
        conn->want_read = false;
        conn->want_write = true;

        // The socket is likely ready to write in a request-response protocol,
        // try to write it without waiting for the next iteration.
        return handle_write(conn);      // optimization

    } else {
        // want read if no data in buff to write
        conn->want_read = true;
        conn->want_write = false;
    }
}

void handle_write(Conn *conn) {
    assert(conn->outgoing.size() > 0);

    ssize_t rv = write(conn->fd, conn->outgoing.data(), conn->outgoing.size());
    if (rv < 0 && errno == EAGAIN) {
        return; // actually not ready
    }
    if (rv < 0) {
        conn->want_close = true; // error handling
        return;
    }

    // remove written data from outgoing buffer
    buf_consume(conn->outgoing, (size_t)rv);

    // switch state to read if all data written
    if (conn->outgoing.size() == 0) {
        // want read if all data written
        conn->want_read = true;
        conn->want_write = false;
    } else {
        // want write if all data not written
        conn->want_read = false;
        conn->want_write = true;
    }
}

int main(void) {

    int s_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (s_fd == -1) {
        std::cerr << "Unable to create a socket" << std::endl;
        return EXIT_FAILURE;
    } else {
        std::cout << "Socket created successfully!" << std::endl;
    }

    // setting SO_REUSEADDR to prevent TIME_WAIT and reuse addresses
    int val = 1;
    if (setsockopt(s_fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val)) < 0) {
        std::cerr << "Unable to set socket option: SO_REUSEADDR" << std::endl;
        return EXIT_FAILURE;
    }

    // initial listening socket
    struct sockaddr_in addr = {};
    addr.sin_family = AF_INET;             // IPv4
    addr.sin_port = htons(PORT_NO);        // port number
    addr.sin_addr.s_addr = htonl(IP_ADDR); // IP addr

    // bind socket to addr
    std::cout << "Trying to bind socket to addr..." << std::endl;

    if (bind(s_fd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
        std::cerr << "Unable to bind socket to addr" << std::endl;
        return EXIT_FAILURE;
    } else {
        std::cout << "Socket bound successfully to addr!" << std::endl;
    }

    // listen to socket
    if (listen(s_fd, SOMAXCONN) == -1) {
        std::cerr << "Unable to listen to socket" << std::endl;
        return EXIT_FAILURE;
    } else {
        char ip_str[INET_ADDRSTRLEN]; // buffer for IPv4 string
        inet_ntop(AF_INET, &addr.sin_addr, ip_str, sizeof(ip_str));
        std::cout << "Listening on " << ip_str << ":" << PORT_NO << std::endl;
    }

    // a map of all client connections, indexed by fd
    std::vector<Conn *> fd_to_conn;

    // list for poll() readiness
    std::vector<struct pollfd> poll_args;

    // event loop
    while (true) {
        // preparing args for poll
        poll_args.clear();

        // put the main listening socket in the first position
        struct pollfd pfd = {s_fd, POLLIN, 0};
        poll_args.push_back(pfd);

        // put rest of connection sockets
        for (Conn *conn : fd_to_conn) {
            if (!conn) {
                continue;
            }

            struct pollfd pfd = {conn->fd, POLLERR, 0};

            if (conn->want_read) {
                pfd.events |= POLLIN;
            }

            if (conn->want_write) {
                pfd.events |= POLLOUT;
            }

            poll_args.push_back(pfd);
        }

        // wait for poll to check readiness
        // waits forever (blocking) for atleast one connection
        int rv = poll(poll_args.data(), (nfds_t)poll_args.size(), -1);
        if (rv < 0 && errno == EINTR) {
            continue; // not an error, process interupted by a signal
        }
        if (rv < 0) {
            std::cerr << "Error while polling connection!" << std::endl;
        }

        // handle the main listening socket
        if (poll_args[0].revents) {
            if (Conn *conn = handle_accept(s_fd)) {
                // put client connection into the map
                if (fd_to_conn.size() <= (size_t)conn->fd) {
                    fd_to_conn.resize(conn->fd + 1);
                }
                fd_to_conn[conn->fd] = conn;
            }
        }

        // handle connection sockets
        for (size_t i = 1; i < poll_args.size(); ++i) {
            uint32_t ready = poll_args[i].revents;
            Conn *conn = fd_to_conn[poll_args[i].fd];

            if (ready & POLLIN) {
                handle_read(conn);
            }

            if (ready & POLLOUT) {
                handle_write(conn);
            }

            // close the socket on conn error
            if ((ready & POLLERR) || conn->want_close) {
                close(conn->fd);
                fd_to_conn[conn->fd] = NULL;
                delete conn;
            }
        }
    }

    // close socket fd
    close(s_fd);

    return EXIT_SUCCESS;
}