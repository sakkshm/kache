#include <cassert>
#include <cstdint>
#include <cstring>
#include <iostream>
#include <map>
#include <vector>

#include "utils.hpp"
#include <arpa/inet.h>
#include <poll.h>
#include <sys/socket.h>
#include <unistd.h>

// Socket Configs
#define PORT_NO 1234 // Port number
#define IP_ADDR 0    // wildcard IP 0.0.0.0

#define MAX_MSG_LEN 4069
#define MAX_MSG_ARGS 64

struct Conn {
    int fd = -1;

    // application's intentions for the event loop
    bool want_read = false;
    bool want_write = false;
    bool want_close = false;

    // buffered i/o
    std::vector<uint8_t> incoming; // data to be parsed by the application
    std::vector<uint8_t> outgoing; // responses generated by the application
};

struct Response {
    resp_status_code status = OK;
    std::vector<uint8_t> data;
};

// mock KV store
std::map<std::string, std::string> g_data;

// Helper Functions

void buf_append(std::vector<uint8_t> &buf, const uint8_t *data, size_t len) {
    buf.insert(buf.end(), data, data + len);
}

void buf_consume(std::vector<uint8_t> &buf, size_t n) {
    buf.erase(buf.begin(), buf.begin() + n);
}

bool read_u32(const uint8_t *&curr, const uint8_t *end, uint32_t &out) {
    if (curr + 4 > end) {
        return false;
    }

    memcpy(&out, curr, 4);
    curr += 4;

    return true;
}

bool read_str(const uint8_t *&curr, const uint8_t *end, size_t n,
              std::string &out) {
    if (curr + n > end) {
        return false;
    }

    out.assign(curr, curr + n);
    curr += n;

    return true;
}

// Request Handler function

bool parse_req(const uint8_t *data, size_t len, std::vector<std::string> &cmd) {
    const uint8_t *end = data + len;
    uint32_t nstr = 0;

    if (!read_u32(data, end, nstr)) {
        return false; // protocol error: invalid size
    }

    if (nstr > MAX_MSG_ARGS) {
        return false; // safety limit
    }

    while (cmd.size() < nstr) {
        uint32_t len = 0;
        if (!read_u32(data, end, len)) {
            return false; // protocol error: invalid size
        }

        std::string s;
        if (!read_str(data, end, len, s)) {
            return false;
        }

        cmd.push_back(s);
    }

    if (data != end) {
        return false; // trailing garbage, protocol error
    }

    return true;
}

void do_request(std::vector<std::string> &cmd, Response &out) {
    if (cmd.size() == 2 && cmd[0] == "get") {
        auto it = g_data.find(cmd[1]);
        if (it == g_data.end()) {
            out.status = RES_NX; // val not found
            return;
        }

        const std::string &val = it->second;
        out.data.assign(val.begin(), val.end());
    } else if (cmd.size() == 3 && cmd[0] == "set") {
        g_data[cmd[1]].swap(cmd[2]);
    } else if (cmd.size() == 2 && cmd[0] == "del") {
        g_data.erase(cmd[1]);
    } else {
        out.status = RES_ERR; // unrecognized command
    }
}

void make_response(const Response &resp, std::vector<uint8_t> &out) {

    /*

        Output spec:

        [4 bytes]   resp len
        [4 bytes]   status code
        [n bytes]   response

    */

    uint32_t resp_len = 4 + (uint32_t)resp.data.size();

    buf_append(out, (const uint8_t *)&resp_len, 4);
    buf_append(out, (const uint8_t *)&resp.status, 4);
    buf_append(out, resp.data.data(), resp.data.size());
}

bool try_handling_request(Conn *conn) {

    /*
        protocol spec

        [4 bytes]   (size of msg)
        [n bytes]   (msg of n bytes)
        [4 bytes]
        [n bytes]
        ...

    */

    /*
        message spec

        Input:

        [n strings] (no. of strings) (4 bytes)
        [len 1]     (len of str 1)   (4 bytes)
        [str 1]     (string 1)
        [len 2]     (len of str 2)   (4 bytes)
        [str 2]     (string 2)
        .
        .
        .
        [len n]     (len of str n)   (4 bytes)
        [str n]     (string n)


        Output:
        [status]    (status code)    (4 bytes)
        [data]      (data)

    */

    // process the messsage

    // try to parse accumulated buffer
    // Protocol: message header
    if (conn->incoming.size() < 4) {
        return false; // want read
    }

    // extract clients info
    struct sockaddr_in addr = {};
    socklen_t addr_len = sizeof(addr);
    getpeername(conn->fd, (struct sockaddr *)&addr, &addr_len);

    // convert addr to readable form
    char ip_str[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &addr.sin_addr, ip_str, sizeof(ip_str));

    std::cout << "========================================" << std::endl;

    std::cout << "Message recieved from client " << ip_str << ":"
              << addr.sin_port << std::endl;

    // find message length
    uint32_t len = 0;
    memcpy(&len, conn->incoming.data(), 4);

    if (len > MAX_MSG_LEN) { // protocol error
        conn->want_close = true;
        return false; // want close
    }

    std::cout << "Message length: " << len << std::endl;

    // Protocol: message body
    if (conn->incoming.size() < 4 + len) {
        return false; // want read
    }

    // raw message content
    std::string msg(conn->incoming.begin(), conn->incoming.end());
    std::cout << "Raw Message content: " << msg << std::endl;

    const uint8_t *request = &conn->incoming[4];

    std::vector<std::string> cmd;
    if (parse_req(request, len, cmd) == false) {
        conn->want_close = true;
        return false;
    }

    // parsed request commands
    std::cout << "Commands: ";
    for (auto c : cmd) {
        std::cout << c << " ";
    }
    std::cout << std::endl;

    
    struct Response resp;
    do_request(cmd, resp);
    make_response(resp, conn->outgoing);

    std::cout << "========================================" << std::endl;

    // remove from incoming buffer
    buf_consume(conn->incoming, 4 + len);
    return true; // success
}

Conn *handle_accept(int fd) {
    // accept
    struct sockaddr_in client_addr = {};
    socklen_t addrlen = sizeof(client_addr);

    int conn_fd = accept(fd, (struct sockaddr *)&client_addr, &addrlen);

    if (conn_fd < 0) {
        // error
        std::cerr << "Unable to connect to this client..." << std::endl;
        return NULL;
    }

    // set connection fd to nonblocking mode
    fd_set_nonblock(conn_fd);

    // create a Conn struct
    Conn *conn = new Conn();
    conn->fd = conn_fd;
    conn->want_read = true; // read 1st request
    return conn;
}

void handle_write(Conn *conn) {
    assert(conn->outgoing.size() > 0);

    ssize_t rv = write(conn->fd, conn->outgoing.data(), conn->outgoing.size());
    if (rv < 0 && errno == EAGAIN) {
        return; // actually not ready
    }
    if (rv < 0) {
        conn->want_close = true; // error handling
        return;
    }

    // remove written data from outgoing buffer
    buf_consume(conn->outgoing, (size_t)rv);

    // switch state to read if all data written
    if (conn->outgoing.size() == 0) {
        // want read if all data written
        conn->want_read = true;
        conn->want_write = false;
    } else {
        // want write if all data not written
        conn->want_read = false;
        conn->want_write = true;
    }
}

void handle_read(Conn *conn) {
    // Do a non blocking read
    uint8_t buf[64 * 1024];
    ssize_t rv = read(conn->fd, buf, sizeof(buf));

    if (rv <= 0) {
        // Handle i/o error or EOF
        conn->want_close = true;
        return;
    }

    // add data to incoming buffer
    buf_append(conn->incoming, buf, (size_t)rv);

    // try to parse incoming messages
    // up until no message if left in buffer
    // (pipilined/batched requests)
    // process parsed message
    // remove from buffer
    while (true) {
        if (!try_handling_request(conn)) {
            break;
        }
    }

    // switch state to write if data is ready to be written
    if (conn->outgoing.size() > 0) {
        // want write if some data in buf to write
        conn->want_read = false;
        conn->want_write = true;

        // The socket is likely ready to write in a request-response protocol,
        // try to write it without waiting for the next iteration.
        return handle_write(conn); // optimization

    } else {
        // want read if no data in buff to write
        conn->want_read = true;
        conn->want_write = false;
    }
}

int main(void) {

    int s_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (s_fd == -1) {
        std::cerr << "Unable to create a socket" << std::endl;
        return EXIT_FAILURE;
    } else {
        std::cout << "Socket created successfully!" << std::endl;
    }

    // setting SO_REUSEADDR to prevent TIME_WAIT and reuse addresses
    int val = 1;
    if (setsockopt(s_fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val)) < 0) {
        std::cerr << "Unable to set socket option: SO_REUSEADDR" << std::endl;
        return EXIT_FAILURE;
    }

    // initial listening socket
    struct sockaddr_in addr = {};
    addr.sin_family = AF_INET;             // IPv4
    addr.sin_port = htons(PORT_NO);        // port number
    addr.sin_addr.s_addr = htonl(IP_ADDR); // IP addr

    // bind socket to addr
    std::cout << "Trying to bind socket to addr..." << std::endl;

    if (bind(s_fd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
        std::cerr << "Unable to bind socket to addr" << std::endl;
        return EXIT_FAILURE;
    } else {
        std::cout << "Socket bound successfully to addr!" << std::endl;
    }

    // listen to socket
    if (listen(s_fd, SOMAXCONN) == -1) {
        std::cerr << "Unable to listen to socket" << std::endl;
        return EXIT_FAILURE;
    } else {
        char ip_str[INET_ADDRSTRLEN]; // buffer for IPv4 string
        inet_ntop(AF_INET, &addr.sin_addr, ip_str, sizeof(ip_str));
        std::cout << "Listening on " << ip_str << ":" << PORT_NO << std::endl;
    }

    // a map of all client connections, indexed by fd
    std::vector<Conn *> fd_to_conn;

    // list for poll() readiness
    std::vector<struct pollfd> poll_args;

    // event loop
    while (true) {
        // preparing args for poll
        poll_args.clear();

        // put the main listening socket in the first position
        struct pollfd pfd = {s_fd, POLLIN, 0};
        poll_args.push_back(pfd);

        // put rest of connection sockets
        for (Conn *conn : fd_to_conn) {
            if (!conn) {
                continue;
            }

            struct pollfd pfd = {conn->fd, POLLERR, 0};

            if (conn->want_read) {
                pfd.events |= POLLIN;
            }

            if (conn->want_write) {
                pfd.events |= POLLOUT;
            }

            poll_args.push_back(pfd);
        }

        // wait for poll to check readiness
        // waits forever (blocking) for atleast one connection
        int rv = poll(poll_args.data(), (nfds_t)poll_args.size(), -1);
        if (rv < 0 && errno == EINTR) {
            continue; // not an error, process interupted by a signal
        }
        if (rv < 0) {
            std::cerr << "Error while polling connection!" << std::endl;
        }

        // handle the main listening socket
        if (poll_args[0].revents) {
            if (Conn *conn = handle_accept(s_fd)) {
                // put client connection into the map
                if (fd_to_conn.size() <= (size_t)conn->fd) {
                    fd_to_conn.resize(conn->fd + 1);
                }
                fd_to_conn[conn->fd] = conn;
            }
        }

        // handle connection sockets
        for (size_t i = 1; i < poll_args.size(); ++i) {
            uint32_t ready = poll_args[i].revents;
            Conn *conn = fd_to_conn[poll_args[i].fd];

            if (ready & POLLIN) {
                handle_read(conn);
            }

            if (ready & POLLOUT) {
                handle_write(conn);
            }

            // close the socket on conn error
            if ((ready & POLLERR) || conn->want_close) {
                close(conn->fd);
                fd_to_conn[conn->fd] = NULL;
                delete conn;
            }
        }
    }

    // close socket fd
    close(s_fd);

    return EXIT_SUCCESS;
}